# 怎么计算算法时间与空间复杂度?【时间复杂度】

一段代码执行过程中，通常会伴有时间与空间的消耗，那么如何计算呢？

## 时间复杂度

#### 常见的时间复杂度计量单位

- 常数 O(1)
- 对数 O(logN)
- 线性 O(n)
- 线性对数 O(nlogN)
- 平方 O(n^2)
- 立方 O(n^3)
- K次方 O(n^k)
- 指数 (2^n)

##### 常数（O(1)）

通常没有循环体等结构的语句，即便是百、千、万行的代码，时间复杂度都始终是一个常数。

```js
// 一行代码语句的时间复杂度通常为 O(1)
const  a = 1;
```

##### 线性（O(n)）

可以理解为，时间复杂度像一个一元一次方程一样，线性增长，且成正比。

```js
const n = 1000;

for(let i = 0; i< 1000; i++) {  console.log(i) }

```

其中`const n = 1000`,时间复杂度可以理解为`T = 1`，然后是`for`循环中，`let i =1`花费了`T = 1`，`1 < n`花费了`T = n + 1`，
然后是`i++`、`console.log(i)`花费了`T = 2n`，所以总和为`T = 3n + 3`;

但是这里的时间复杂度只考虑当`n`趋于无穷大时的情况，所以忽略常数项，忽略高阶系数项。最终为`T = n`，也即`T = O(n)`;

##### 对数 O(logN)

```js
let x = 1;

while(x < y) {
    x = x*2;
}

```

怎么计算呢？

一起来解一道方程题目吧：什么时候会跳出循环？

当`2*x >= y`的时候？应该会吧，毕竟`y`的值不确定。不考虑x的值，单纯从循环角度讲，每次循环目标值都`*2`，那么假设循环`n`次就是`(2x)^n = y`，也即`2^n = y`，
所以也就是`n = logy`，所以复杂度为`O(logN)`;

##### 线性对数 O(nlogN)

看到这里，你有灵感了吗？外边套一个循环体就可以解决。

```js
for(let i = 0, i < n; i ++) {
    let x = 1;
    
    while(x < y) {
        x = x*2;
    }
}
```

##### O(n^2)

同样，双层`for`循环就是`O(n^2)`，剩余的套路，你基本也熟悉了。

